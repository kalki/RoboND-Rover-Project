import timeimport numpy as npimport navigatable_area as navfrom navigatable_area import NavigationAreafrom rover_status import RoverStatusfrom rover_controller import RoverControllerimport rover_controller as rocimport rock_locator as rolimport path_finder as pfRETURN_POINT = (100, 90)def to_polar_coords(x_pixel, y_pixel):    __dist = np.sqrt(x_pixel ** 2 + y_pixel ** 2)    __angles = np.arctan2(y_pixel, x_pixel)    return __dist, __anglesdef decide_speed_rate(navigation_area):    __speed_rate = 1.0    __na = navigation_area    if not __na.is_area_open(nav.L_FRONT_FAR_NAME) or not __na.is_area_open(nav.R_FRONT_FAR_NAME):        __speed_rate = 0.5    return __speed_ratedef is_front_blocked(navigation_area):    lfc_block = navigation_area.is_area_blocked(nav.L_FRONT_CLOSE_NAME)    rfc_block = navigation_area.is_area_blocked(nav.R_FRONT_CLOSE_NAME)    return lfc_block and rfc_blockdef is_left_guide_has_visual(navigation_area):    lg_open = navigation_area.is_area_open(nav.L_GUIDE_NAME)    return not lg_opendef is_left_edge_missing(navigation_area):    lec_clear = navigation_area.is_area_clear(nav.L_EDGE_CLOSE_NAME)    lef_clear = navigation_area.is_area_clear(nav.L_EDGE_FAR_NAME)    lg_clear = navigation_area.is_area_clear(nav.L_GUIDE_NAME)    return lec_clear and lef_clear and lg_cleardef is_both_edge_blocked(navigation_area):    lef_block = navigation_area.is_area_blocked(nav.L_EDGE_FAR_NAME)    ref_block = navigation_area.is_area_blocked(nav.R_EDGE_FAR_NAME)    return lef_block and ref_blockdef is_left_edge_hard_left(navigation_area):    lec_clear = navigation_area.is_area_clear(nav.L_EDGE_CLOSE_NAME)    lef_normal = navigation_area.is_area_normal(nav.L_EDGE_FAR_NAME)    lef_clear = navigation_area.is_area_clear(nav.L_EDGE_FAR_NAME)    lg_clear = navigation_area.is_area_clear(nav.L_GUIDE_NAME)    lff_block = navigation_area.is_area_blocked(nav.L_FRONT_FAR_NAME)    rff_block = navigation_area.is_area_blocked(nav.R_FRONT_FAR_NAME)    return (lec_clear and lef_clear and not lg_clear) or (lef_normal and (not lff_block) and rff_block)def is_left_edge_left(navigation_area):    lef_block = navigation_area.is_area_blocked(nav.L_EDGE_FAR_NAME)    ref_block = navigation_area.is_area_blocked(nav.R_EDGE_FAR_NAME)    lef_open = navigation_area.is_area_open(nav.L_EDGE_FAR_NAME)    # return (not lef_block and ref_block) or lec_open or lef_open    return (not lef_block and ref_block) or lef_opendef is_left_edge_normal(navigation_area):    lef_noraml = navigation_area.is_area_normal(nav.L_EDGE_FAR_NAME)    return lef_noramldef is_left_edge_right(navigation_area):    lef_block = navigation_area.is_area_blocked(nav.L_EDGE_FAR_NAME)    return lef_blockdef is_left_edge_hard_right(navigation_area):    lff_block = navigation_area.is_area_blocked(nav.L_FRONT_FAR_NAME)    return is_left_edge_normal(navigation_area) and lff_blockdef get_unnavigated_point(rover):    __start_x = int(rover.pos[0] / (rover.worldmap.shape[1] / 2)) * rover.worldmap.shape[1]    __start_y = int(rover.pos[1] / (rover.worldmap.shape[0] / 2)) * rover.worldmap.shape[0]    __start = (__start_x, __start_y)    __goal = (rover.pos[0], rover.pos[1])    __img_obstacles = rover.worldmap[:, :, 0]    __img_navigatable = rover.worldmap[:, :, 2]    __img = np.ones_like(__img_obstacles)    __obstacles_select = __img_obstacles > 0    __navigatable_select = __img_navigatable > 0    __img[__obstacles_select] = 0    __img[__navigatable_select] = 1    __path = pf.search_path(__img, __start, __goal)    if len(__path) <= 0:        return None    __p = pf.get_fisrt_outside_point(__path, __img_navigatable)    return __p# This is where you can build a decision tree for determining throttle, brake and steer# commands based on the output of the perception_step() functiondef decision_step(rover):    rs = RoverStatus(rover)    na = NavigationArea(rs.get_navigation_image())    rc = RoverController(rover, rs)    r_img = rs.get_rock_image()    if rs.is_unstable():        if rs.is_not_moving():            if int(time.time()/3) % 6 == 0:                rc.direction_hard_right()            elif int(time.time()/3) % 6 == 2:                rc.direction_straight()                rc.speed_brake()            elif int(time.time() / 3) % 6 == 4:                rc.speed_up()            else:                rc.do_nothing()        return rover    if not rs.has_vision():        rc.speed_up()        rc.direction_straight()        return rover    if rover.mode == rc.MODE_FINISH:        return rover    if rover.mode == rc.MODE_ROCK_APPROACH:        rs.stop_recording_position()        if rover.near_sample and rover.vel == 0 and not rover.picking_up:            rover.send_pickup = True        if rol.is_rock_insight(r_img):            __d, __a = rol.get_closest_rock_polar(r_img)            if rover.near_sample:                rc.speed_brake()            else:                if __d > 40:                    rc.speed_limit(0.4)                    rc.direction_to(__a/8)                elif __d > 20:                    rc.speed_limit(0.2)                    rc.direction_to(__a/4)                elif __d > 10:                    rc.speed_limit(0.1)                    rc.direction_to(__a)                else:                    if rs.is_moving():                        rc.speed_brake()                    else:                        rc.do_nothing()        else:            rc.mode_to_forward()        if rs.get_mode_time() > 20:            rc.mode_to_turn_fix()        return rover    if rover.mode == rc.MODE_NAVIGATE:        __start = (rover.pos[0], rover.pos[1])        __goal = rc.get_goal()        __waypoint = rc.get_waypoint()        if rc.is_goal_reached():            if __goal == RETURN_POINT:                rc.set_goal((0, 0))                rc.mode_to_finish()                return rover            else:                rc.set_goal((0, 0))                rc.mode_to_forward()                return rover        if __goal != (0, 0) and __waypoint == (0, 0):            __navigatable = rs.get_navigation_map()            __path = pf.search_path(__navigatable, __start, __goal)            if len(__path) > 0:                __path = pf.reduce_path(__path, __navigatable)                __w = __path[-1]                if roc.is_close(__w, __start):                    __w = __path[-2]                rc.set_waypoint(__w)                __waypoint = rc.get_waypoint()        if __waypoint != (0, 0):            rc.head_to_waypoint()        else:            if rs.is_not_moving():                rc.mode_to_turn_fix()            elif is_front_blocked(na):                rc.mode_to_turn_fix()            else:                rs.update_status()                rc.speed_up()                rc.direction_navigatable()        return rover    if rover.mode == rc.MODE_FORWARD or rover.mode == rc.MODE_FOLLOW_LEFT:        if rs.has_vision_for_navigate_during_forward():            if rs.is_on_old_way_too_long():                __goal = RETURN_POINT                __start = (rover.pos[0], rover.pos[1])                __navigatable = rs.get_navigation_map()                __path = pf.search_path(__navigatable, __start, __goal)                if len(__path) > 0:                    rc.mode_to_navigate(__goal)                    return rover            if rol.is_rock_insight(r_img):                rc.mode_to_rock_approach()            else:                rs.update_status()                speed_rate = decide_speed_rate(na)                rc.speed_up(speed_rate)                if rs.is_not_moving():                    rc.mode_to_turn_fix()                elif is_front_blocked(na):                    rc.mode_to_turn_fix()                else:                    if rover.mode == rc.MODE_FORWARD:                        if is_left_guide_has_visual(na):                            rc.mode_to_follow_left()                        else:                            rc.direction_navigatable()                    else:                        if is_left_edge_missing(na):                            rc.mode_to_find_left()                        elif is_both_edge_blocked(na):                            rc.direction_straight()                        elif is_left_edge_hard_left(na):                            rc.do_nothing()                            rc.direction_hard_left()                        elif is_left_edge_left(na):                            rc.direction_left()                        elif is_left_edge_right(na):                            rc.direction_right()                        elif is_left_edge_hard_right(na):                            rc.do_nothing()                            rc.direction_hard_right()                        elif is_left_edge_normal(na):                            rc.direction_straight()        else:            rc.mode_to_stop()    elif rover.mode == rc.MODE_FIND_LEFT:        if rs.is_moving():            rc.speed_brake()            rc.direction_straight()        else:            if rs.get_yaw_diff_since_snapshot() > 60:                rc.mode_to_forward()            else:                rc.do_nothing()                rc.direction_hard_left()    elif rover.mode == rc.MODE_TURN_FIX_ANGEL:        if rs.is_moving():            rc.speed_brake()            rc.direction_straight()        else:            if rs.get_yaw_diff_since_snapshot() > 15:                rc.mode_to_forward()            else:                rc.do_nothing()                rc.direction_hard_right()    elif rover.mode == rc.MODE_STOP:        if rs.is_moving():            rc.speed_brake()            rc.direction_straight()        else:            if not rs.has_vision_for_start_moving():                rc.do_nothing()                rc.direction_hard_right()            else:                rc.mode_to_forward()    return rover