import timeimport numpy as npimport navigatable_area as navfrom navigatable_area import NavigationAreafrom rover_status import RoverStatusfrom rover_controller import RoverControllerimport rock_locator as rolimport path_finder as pfRETURN_POINT = (100, 90)def to_polar_coords(x_pixel, y_pixel):    __dist = np.sqrt(x_pixel ** 2 + y_pixel ** 2)    __angles = np.arctan2(y_pixel, x_pixel)    return __dist, __anglesdef decide_speed_rate(navigation_area):    __speed_rate = 1.0    __na = navigation_area    if not __na.is_area_open(nav.L_FRONT_FAR_NAME) or not __na.is_area_open(nav.R_FRONT_FAR_NAME):        __speed_rate = 0.5    return __speed_ratedef is_left_front_blocked(navigation_area):    li_block = navigation_area.is_area_blocked(nav.L_IMPACT_NAME)    lfc_block = navigation_area.is_area_blocked(nav.L_FRONT_CLOSE_NAME)    return li_block or lfc_blockdef is_right_front_blocked(navigation_area):    ri_block = navigation_area.is_area_blocked(nav.R_IMPACT_NAME)    rfc_block = navigation_area.is_area_blocked(nav.R_FRONT_CLOSE_NAME)    return ri_block or rfc_blockdef is_front_blocked(navigation_area):    lfc_block = navigation_area.is_area_blocked(nav.L_FRONT_CLOSE_NAME)    rfc_block = navigation_area.is_area_blocked(nav.R_FRONT_CLOSE_NAME)    return lfc_block and rfc_blockdef is_left_guide_has_visual(navigation_area):    lg_open = navigation_area.is_area_open(nav.L_GUIDE_NAME)    return not lg_opendef is_left_edge_missing(navigation_area):    lec_clear = navigation_area.is_area_clear(nav.L_EDGE_CLOSE_NAME)    lef_clear = navigation_area.is_area_clear(nav.L_EDGE_FAR_NAME)    lg_clear = navigation_area.is_area_clear(nav.L_GUIDE_NAME)    return lec_clear and lef_clear and lg_cleardef is_both_edge_blocked(navigation_area):    lef_block = navigation_area.is_area_blocked(nav.L_EDGE_FAR_NAME)    ref_block = navigation_area.is_area_blocked(nav.R_EDGE_FAR_NAME)    return lef_block and ref_blockdef is_left_edge_hard_left(navigation_area):    lec_clear = navigation_area.is_area_clear(nav.L_EDGE_CLOSE_NAME)    lef_normal = navigation_area.is_area_normal(nav.L_EDGE_FAR_NAME)    lef_clear = navigation_area.is_area_clear(nav.L_EDGE_FAR_NAME)    lg_clear = navigation_area.is_area_clear(nav.L_GUIDE_NAME)    lff_block = navigation_area.is_area_blocked(nav.L_FRONT_FAR_NAME)    rff_block = navigation_area.is_area_blocked(nav.R_FRONT_FAR_NAME)    return (lec_clear and lef_clear and not lg_clear) or (lef_normal and (not lff_block) and rff_block)def is_left_edge_left(navigation_area):    lef_block = navigation_area.is_area_blocked(nav.L_EDGE_FAR_NAME)    ref_block = navigation_area.is_area_blocked(nav.R_EDGE_FAR_NAME)    lef_open = navigation_area.is_area_open(nav.L_EDGE_FAR_NAME)    # return (not lef_block and ref_block) or lec_open or lef_open    return (not lef_block and ref_block) or lef_opendef is_left_edge_normal(navigation_area):    lef_noraml = navigation_area.is_area_normal(nav.L_EDGE_FAR_NAME)    return lef_noramldef is_left_edge_right(navigation_area):    lef_block = navigation_area.is_area_blocked(nav.L_EDGE_FAR_NAME)    return lef_blockdef is_left_edge_hard_right(navigation_area):    lff_block = navigation_area.is_area_blocked(nav.L_FRONT_FAR_NAME)    return is_left_edge_normal(navigation_area) and lff_blockdef get_unnavigated_point(rover):    __start_x = int(rover.pos[0] / (rover.worldmap.shape[1] / 2)) * rover.worldmap.shape[1]    __start_y = int(rover.pos[1] / (rover.worldmap.shape[0] / 2)) * rover.worldmap.shape[0]    __start = (__start_x, __start_y)    __goal = (rover.pos[0], rover.pos[1])    __img_obstacles = rover.worldmap[:, :, 0]    __img_navigatable = rover.worldmap[:, :, 2]    __img = np.ones_like(__img_obstacles)    __obstacles_select = __img_obstacles > 0    __navigatable_select = __img_navigatable > 0    __img[__obstacles_select] = 0    __img[__navigatable_select] = 1    __path = pf.search_path(__img, __start, __goal)    if len(__path) <= 0:        return None    __p = pf.get_fisrt_outside_point(__path, __img_navigatable)    return __p# This is where you can build a decision tree for determining throttle, brake and steer# commands based on the output of the perception_step() functiondef decision_step(rover):    rs = RoverStatus(rover)    na = NavigationArea(rs.get_navigation_image())    rc = RoverController(rover, rs)    r_img = rs.get_rock_image()    if rs.is_unstable():        if rs.is_not_moving():            if int(time.time()/3) % 6 == 0:                rc.direction_hard_right()            elif int(time.time()/3) % 6 == 2:                rc.direction_straight()                rc.speed_brake()            elif int(time.time() / 3) % 6 == 4:                rc.speed_up()            else:                rc.do_nothing()        return rover    if not rs.has_vision():        rc.speed_up()        rc.direction_straight()        return rover    if rover.mode == rc.MODE_FINISH:        return rover    if rover.mode == rc.MODE_ROCK_APPROACH:        rs.stop_recording_position()        if rover.near_sample and rover.vel == 0 and not rover.picking_up:            rover.send_pickup = True        if rol.is_rock_insight(r_img):            __d, __a = rol.get_closest_rock_polar(r_img)            if rover.near_sample:                rc.speed_brake()            else:                if __d > 40:                    rc.speed_limit(0.4)                    rc.direction_to(__a/8)                elif __d > 20:                    rc.speed_limit(0.2)                    rc.direction_to(__a/4)                elif __d > 10:                    rc.speed_limit(0.1)                    rc.direction_to(__a)                else:                    if rs.is_moving():                        rc.speed_brake()                    else:                        rc.do_nothing()        else:            rc.mode_to_forward()        if rs.get_mode_time() > 30:            rc.mode_to_forward()        return rover    if rover.mode == rc.MODE_NAVIGATE:        __start = (rover.pos[0], rover.pos[1])        __goal = rc.goal[0]        __navigatable = rs.get_navigation_map()        __obstacles = rs.get_obstacles_map()        __obstacles_sel = __obstacles > __navigatable        __navigatable[__obstacles_sel] = 0        __path = pf.search_path(__navigatable, __start, __goal)        if len(__path) > 0:            __path = pf.reduce_path(__path, __navigatable)        if len(__path) > 0:            __nav_point = __path[-1]            __t_x = __nav_point[0]            __t_y = __nav_point[1]            __s_x = int(rover.pos[0])            __s_y = int(rover.pos[1])            __t_yaw = np.arctan2(__t_y - __s_y, __t_x - __s_x) * 180 / np.pi            __t_dist = np.sqrt((__t_x - __s_x) ** 2 + (__t_y - __s_y) ** 2)            if __t_yaw < 0:                __t_yaw = __t_yaw + 360            __yaw_diff = (__t_yaw - rover.yaw)            print("way {:} yaw {:} dist {:}".format(__nav_point, __yaw_diff, __t_dist))            if np.abs(__yaw_diff) > 5:                if rover.vel > 0.2:                    rc.speed_brake()                else:                    rc.do_nothing()                    rc.direction_to_yaw(__yaw_diff / 2)            else:                if __t_dist > 10:                    rc.speed_up()                elif __t_dist > 5:                    rc.speed_limit(0.5)                elif __t_dist > 2:                    rc.speed_limit(0.5)                else:                    if __goal == RETURN_POINT:                        rc.mode_to_finish()                        return rover                    else:                        rc.mode_to_forward()                        return rover                if is_left_front_blocked(na):                    rc.direction_right()                elif is_right_front_blocked(na):                    rc.direction_left()                else:                    rc.direction_to_yaw(__yaw_diff)        else:            if np.abs(rover.pos[0] - __goal[0]) < 3 and np.abs(rover.pos[1] - __goal[1]) < 3:                if __goal == RETURN_POINT:                    rc.mode_to_finish()                    return rover                else:                    rc.mode_to_forward()                    return rover            rs.update_status()            rc.speed_up()            if rs.is_not_moving():                rc.mode_to_turn_fix()            elif is_front_blocked(na):                rc.mode_to_turn_fix()            else:                rc.direction_navigatable()        return rover    if rover.mode == rc.MODE_FORWARD or rover.mode == rc.MODE_FOLLOW_LEFT:        if rs.has_vision_for_navigate_during_forward():            if rs.is_on_old_way_too_long():                __goal = RETURN_POINT                __start = (rover.pos[0], rover.pos[1])                __navigatable = rs.get_navigation_map().copy()                __obstacles = rs.get_obstacles_map()                __obstacles_sel = __obstacles > __navigatable                __navigatable[__obstacles_sel] = 0                __path = pf.search_path(__navigatable, __start, __goal)                if len(__path) > 0:                    rc.mode_to_navigate(__goal)                    return rover            if rol.is_rock_insight(r_img):                rc.mode_to_rock_approach()            else:                rs.update_status()                speed_rate = decide_speed_rate(na)                rc.speed_up(speed_rate)                if rs.is_not_moving():                    rc.mode_to_turn_fix()                elif is_front_blocked(na):                    rc.mode_to_turn_fix()                else:                    if rover.mode == rc.MODE_FORWARD:                        if is_left_guide_has_visual(na):                            rc.mode_to_follow_left()                        else:                            rc.direction_navigatable()                    else:                        if is_left_edge_missing(na):                            rc.mode_to_find_left()                        elif is_both_edge_blocked(na):                            rc.direction_straight()                        elif is_left_edge_hard_left(na):                            rc.do_nothing()                            rc.direction_hard_left()                        elif is_left_edge_left(na):                            rc.direction_left()                        elif is_left_edge_right(na):                            rc.direction_right()                        elif is_left_edge_hard_right(na):                            rc.do_nothing()                            rc.direction_hard_right()                        elif is_left_edge_normal(na):                            rc.direction_straight()        else:            rc.mode_to_stop()    elif rover.mode == rc.MODE_FIND_LEFT:        if rs.is_moving():            rc.speed_brake()            rc.direction_straight()        else:            if rs.get_yaw_diff_since_snapshot() > 60:                rc.mode_to_forward()            else:                rc.do_nothing()                rc.direction_hard_left()    elif rover.mode == rc.MODE_TURN_FIX_ANGEL:        if rs.is_moving():            rc.speed_brake()            rc.direction_straight()        else:            if rs.get_yaw_diff_since_snapshot() > 15:                rc.mode_to_forward()            else:                rc.do_nothing()                rc.direction_hard_right()    elif rover.mode == rc.MODE_STOP:        if rs.is_moving():            rc.speed_brake()            rc.direction_straight()        else:            if not rs.has_vision_for_start_moving():                rc.do_nothing()                rc.direction_hard_right()            else:                rc.mode_to_forward()    return rover